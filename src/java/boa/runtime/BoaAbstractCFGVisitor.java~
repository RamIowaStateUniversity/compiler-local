/*
 * Copyright 2014, Hridesh Rajan, Robert Dyer, 
 *                 and Iowa State University of Science and Technology
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package boa.runtime;

import java.util.List;
import java.util.Queue;
import java.util.LinkedList;

import boa.functions.BoaAstIntrinsics;

import boa.types.Ast.*;
import boa.types.Ast.Expression.*;
import boa.types.Control.*;
import boa.types.Code.CodeRepository;
import boa.types.Code.Revision;
import boa.types.Diff.ChangedFile;
import boa.types.Shared.Person;
import boa.types.Toplevel.Project;

/**
 * Boa abstract AST visitor.
 * 
 * The <code>visit()</code> methods first call <code>preVisit()</code> for the node.
 * If <code>preVisit()</code> returns <code>true</code>, then each of that node's children are visited and then <code>postVisit()</code> is called.
 * 
 * By default, all <code>preVisit()</code> methods call {@link #defaultPreVisit()} and return <code>true</code>.
 * By default, all <code>postVisit()</code> methods call {@link #defaultPostVisit()}.
 * 
 * @author rdyer
 */
public abstract class BoaAbstractCFGVisitor {
	/**
	 * Initializes any visitor-specific data before starting a visit.
	 * 
	 * @return itself, to allow method chaining
	 */
	public BoaAbstractCFGVisitor initialize() {
		return this;
	}

	/**
	 * Provides a default action for pre-visiting nodes.
	 * Any <code>preVisit()</code> method that is not overridden calls this method.
	 * 
	 * @return always returns true
	 */
	protected boolean defaultPreVisit() throws Exception {
		return true;
	}

	protected boolean preVisit(final CFG cfg) throws Exception {
		return defaultPreVisit();
	}
	protected boolean preVisit(final CFGNode node) throws Exception {
		return defaultPreVisit();
	}
	protected boolean preVisit(final Variable node) throws Exception {
		return defaultPreVisit();
	}
	protected boolean preVisit(final Statement node) throws Exception {
		return defaultPreVisit();
	}
	protected boolean preVisit(final Expression node) throws Exception {
		return defaultPreVisit();
	}
	protected boolean preVisit(final ExpressionKind node) throws Exception {
		return defaultPreVisit();
	}
	protected boolean preVisit(final ExpressionKind node,final String str) throws Exception {
		return defaultPreVisit();
	}
	

	/**
	 * Provides a default action for post-visiting nodes.
	 * Any <code>postVisit()</code> method that is not overridden calls this method.
	 */
	protected void defaultPostVisit() throws Exception { }

	protected void postVisit(final CFG cfg) throws Exception {
		defaultPostVisit();
	}
	protected void postVisit(final CFGNode node) throws Exception {
		defaultPostVisit();
	}
	protected void postVisit(final Variable node) throws Exception {
		defaultPostVisit();
	}
	protected void postVisit(final Statement node) throws Exception {
		defaultPostVisit();
	}
	protected void postVisit(final Expression node) throws Exception {
		defaultPostVisit();
	}
	protected void postVisit(final ExpressionKind node) throws Exception {
		defaultPostVisit();
	}
	
	public final void visit(final CFG cfg,final boolean bool) throws Exception {
		if (preVisit(cfg)) {
			if(bool) {
				java.util.List<boa.types.Control.CFGEdge> edges=cfg.getEdgesList();
				java.util.HashMap<Integer,String> nodeVisitStatus=new java.util.HashMap<Integer,String>();
				int edgeSize=(int)java.lang.Math.sqrt(edges.size());
				for(int i=0;i<edgeSize;i++) {
					nodeVisitStatus.put(i,"unvisited");
				}
				Queue<Integer> q=new LinkedList<Integer>();
				nodeVisitStatus.put(edgeSize-1,"visited");
				java.util.List<boa.types.Control.CFGNode> nl=sortNodes(cfg.getNodesList());
				visit(nl.get(edgeSize-1));
				q.add(edgeSize-1);
				while(!q.isEmpty()) {
					int index=q.peek();
					for(int i=0;i<edges.size();i+=edgeSize) {
						if(edges.get(i+index).getLabel().getNumber()!=1 && nodeVisitStatus.get(i/edgeSize).equals("unvisited")) {
							System.out.println(i/edgeSize);
							visit(nl.get(i/edgeSize));
							nodeVisitStatus.put(i/edgeSize,"visited");
							q.add(i/edgeSize);
						}
					}
					q.remove();
				}
			}
			else {
				java.util.List<boa.types.Control.CFGEdge> edges=cfg.getEdgesList();
				java.util.HashMap<Integer,String> nodeVisitStatus=new java.util.HashMap<Integer,String>();
				int edgeSize=(int)java.lang.Math.sqrt(edges.size());
				for(int i=0;i<edgeSize;i++) {
					nodeVisitStatus.put(i,"unvisited");
				}
				Queue<Integer> q=new LinkedList<Integer>();
				nodeVisitStatus.put(0,"visited");
				java.util.List<boa.types.Control.CFGNode> nl=sortNodes(cfg.getNodesList());
				visit(nl.get(0));
				q.add(0);
				while(!q.isEmpty()) {
					int index=q.peek();
					for(int i=index*edgeSize;i<(index*edgeSize)+edgeSize;i++) {
						if(edges.get(i).getLabel().getNumber()!=1 && nodeVisitStatus.get(i%edgeSize).equals("unvisited")) {
							System.out.println(i%edgeSize);
							visit(nl.get(i%edgeSize));
							nodeVisitStatus.put(i%edgeSize,"visited");
							q.add(i%edgeSize);		
						}
					}
					q.remove();
				}
			}
			postVisit(cfg);		
		}
	}

	public final java.util.List<boa.types.Control.CFGNode> sortNodes(final java.util.List<boa.types.Control.CFGNode> nodeList) {
		java.util.List<boa.types.Control.CFGNode> nl=new java.util.ArrayList<boa.types.Control.CFGNode>();
		for(boa.types.Control.CFGNode cn:nodeList) {
			int flag=0;
			if(nl.size()>0) {
				for(int i=0;i<nl.size();i++) {
					if(nl.get(i).getId()>cn.getId()) {
						nl.add(i, cn);
						flag=1;	
						break;			
					}
				}
				if(flag==0) {
				nl.add(cn);
				}
				flag=0;
			}
			else {
				nl.add(cn);			
			}
		}
		return nl;
	}
/*	public final void visit(final CFG cfg) throws Exception {
		if (preVisit(cfg)) {
			java.util.List<boa.types.Control.CFGEdge> edges=cfg.getEdgesList();
			java.util.HashMap<Integer,String> nodeVisitStatus=new java.util.HashMap<Integer,String>();
			int edgeSize=(int)java.lang.Math.sqrt(edges.size());
			for(int i=0;i<edgeSize;i++) {
				nodeVisitStatus.put(i,"unvisited");
			}
			nodeVisitStatus.put(0,"visited");
			visit(cfg.getNodes(0));			
			traverse(cfg.getNodes(0),0,edges,edgeSize,nodeVisitStatus,cfg);
		}
	}

	public final void traverse(CFGNode node,int index,java.util.List<boa.types.Control.CFGEdge> edges,int edgeSize,java.util.HashMap<Integer,String> nodeVisitStatus,CFG cfg) throws Exception {
		for(int i=index*edgeSize;i<(index*edgeSize)+edgeSize;i++) {
				if(edges.get(i).getLabel().getNumber()!=1 && nodeVisitStatus.get(i%edgeSize).equals("unvisited")) {
//if(edges.get(i).getLabel().getNumber()!=1) {
					System.out.println(i%edgeSize);
					nodeVisitStatus.put(i%edgeSize,"visited");
					visit(cfg.getNodes(i%edgeSize));
					if(index<i%edgeSize) {
						traverse(cfg.getNodes(i%edgeSize),i%edgeSize,edges,edgeSize,nodeVisitStatus,cfg);
					}
				}
			}
	}
*/
	public final void visit(final CFGNode node) throws Exception {
		if (preVisit(node)) {
			if(node.getStatement()!=null) {
				visit(node.getStatement());
			}
			if(node.getExpression()!=null) {
				visit(node.getExpression());
			}
			postVisit(node);
		}
	}

	public final void visit(final Variable node) throws Exception {
		if (preVisit(node)) {
			postVisit(node);
		}
	}
	public final void visit(final Statement node) throws Exception {
		if (preVisit(node)) {
			postVisit(node);
		}
	}
	public final void visit(final Expression node) throws Exception {
		if (preVisit(node)) {
			final List<Expression> expressionsList = node.getExpressionsList();
			final int expressionsSize = expressionsList.size();
			for (int i = 0; i < expressionsSize; i++)
				visit(expressionsList.get(i));

			final List<Variable> varDeclsList = node.getVariableDeclsList();
			final int varDeclsSize = varDeclsList.size();
			for (int i = 0; i < varDeclsSize; i++)
				visit(varDeclsList.get(i));

			if (node.hasNewType())
				visit(node.getNewType());

			final List<Type> genericParametersList = node.getGenericParametersList();
			final int genericParametersSize = genericParametersList.size();
			for (int i = 0; i < genericParametersSize; i++)
				visit(genericParametersList.get(i));

			final List<Expression> methodArgsList = node.getMethodArgsList();
			final int methodArgsSize = methodArgsList.size();
			for (int i = 0; i < methodArgsSize; i++)
				visit(methodArgsList.get(i));

			if (node.hasAnonDeclaration())
				visit(node.getAnonDeclaration());

			postVisit(node);
		}
	}

	public final void visit(final ExpressionKind node) throws Exception {
		if (preVisit(node)) {
			postVisit(node);
		}
	}

	public final void visit(final ExpressionKind node,String type) throws Exception {
		if (preVisit(node,type)) {
			postVisit(node);
		}
	}
}
